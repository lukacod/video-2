<!doctype html><html lang="ko"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" /><title>Lucas Koh Golf — Swing Recorder Pro</title><style>:root{--bg:#05060a; --accent:#fff; --muted:#9aa4ad; --primary:#2f80ed; --red:#ff3b30; --glass:rgba(255,255,255,0.04);}*{box-sizing:border-box}html,body{height:100%;margin:0;background:var(--bg);color:var(--accent);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial}#app{height:100vh;display:flex;flex-direction:column}.topbar{height:64px;display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:linear-gradient(180deg, rgba(0,0,0,0.28), transparent);z-index:20}.icon-btn{width:44px;height:44px;border-radius:10px;border:none;background:var(--glass);color:var(--accent);font-size:20px;cursor:pointer;opacity:1;transition:opacity 0.2s;}.icon-btn:active{transform:scale(0.95)}.icon-btn:disabled{opacity:0.5;cursor:not-allowed;}.title{text-align:center}.app-name{font-weight:700;font-size:15px}.subtitle{font-size:11px;color:var(--muted)}.camera-area{flex:1;position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden}video#preview{width:100%;height:100%;object-fit:cover;background:#000;}/* Onform App-like timer position */.top-timer-wrap{position:absolute;top:10px;left:50%;transform:translateX(-50%);z-index:10;display:none;align-items:center;gap:6px;}.top-timer-wrap.active{display:flex;}.top-timer-dot{width:10px;height:10px;border-radius:50%;background:var(--red);animation:pulse 1s infinite alternate;}.top-timer{background:rgba(0,0,0,0.65);padding:6px 10px;border-radius:6px;font-variant-numeric:tabular-nums;font-weight:700;color:var(--accent);font-size:14px;letter-spacing:0.5px}@keyframes pulse {from { opacity: 1; }to { opacity: 0.5; }}.controls{position:absolute;left:0;right:0;bottom:28px;display:flex;justify-content:center;pointer-events:none}.record-wrap{pointer-events:auto;display:flex;flex-direction:column;align-items:center}.record{width:88px;height:88px;border-radius:50%;border:6px solid rgba(255,255,255,0.15);background:transparent;display:flex;align-items:center;justify-content:center;box-shadow:0 12px 30px rgba(0,0,0,0.6);transition:transform .12s, border-color .2s;cursor:pointer}.record:active{transform:scale(0.95)}.record.recording{border-color:var(--red);}.record.recording .inner{border-radius:12px;width:30px;height:30px;background:var(--red);box-shadow:0 0 0 10px rgba(255,59,48,0.15)}.record:disabled{opacity:0.6;cursor:not-allowed;}.playback{position:fixed;inset:6% 4%;background:linear-gradient(180deg, rgba(3,7,18,0.98), rgba(3,7,18,0.99));border-radius:14px;padding:12px;z-index:50;display:flex;flex-direction:column;gap:12px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}.playback-header{display:flex;justify-content:space-between;align-items:center}.playback-title{font-weight:700}.playback-actions{display:flex;gap:8px}.btn{background:transparent;border:0;color:var(--accent);padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}.btn:active{transform:scale(0.95)}.btn.ghost{background:var(--glass)}.btn.primary{background:var(--primary);color:#fff}.btn.speed{background:var(--glass);min-width:90px;font-weight:700;}.btn.speed.active{background:var(--primary);color:#fff}.playback-body{position:relative}.playback video{width:100%;height:60vh;background:#000;border-radius:8px;object-fit:contain}.speed-overlay{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.75);padding:8px 14px;border-radius:8px;font-weight:700;font-size:16px;color:var(--accent)}.hidden{display:none !important}.playback-controls{display:flex;gap:12px;justify-content:center;padding-top:4px;}.note{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}.message{position:fixed;left:50%;transform:translateX(-50%);bottom:120px;background:rgba(0,0,0,0.8);padding:10px 16px;border-radius:10px;color:var(--accent);z-index:60;font-size:14px}.fps-select{background:var(--glass);border-radius:8px;padding:8px 12px;color:var(--accent);border:0;font-size:14px;font-weight:600;cursor:pointer;-webkit-appearance:none;appearance:none;padding-right:30px;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23fff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3Cpolyline%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 8px center;background-size:16px;}.fps-select option:disabled{color:var(--muted)}</style></head><body><div id="app" class="onform-like"><header class="topbar"><button id="galleryBtn" class="icon-btn" title="사진첩에서 불러오기" aria-label="gallery"><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M21 19V5a2 2 0 0 0-2-2H5C3.895 3 3 3.895 3 5v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 8h.01M16 8h.01M21 19V5a2 2 0 0 0-2-2H5c-1.105 0-2 .895-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM8 12.5l2 2 4-4" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class="title"><div class="app-name">Lucas Koh Golf</div><div class="subtitle">Swing Recorder</div></div><div class="right-controls"><label class="fps-wrap" title="녹화 FPS 선택"><select id="fpsSelect" class="fps-select" aria-label="녹화 FPS"><option value="30">30fps</option><!-- 240fps option will be enabled if supported --><option value="240">240fps</option></select></label></div></header><main class="camera-area">
  <video id="preview" playsinline autoplay muted></video>

  <!-- Onform-style Timer -->
  <div id="topTimerWrap" class="top-timer-wrap">
    <span class="top-timer-dot"></span>
    <div id="topTimer" class="top-timer">00:00.00</div>
  </div>
  
  <div class="controls">
    <div class="record-wrap">
      <button id="recordBtn" class="record" aria-pressed="false" title="녹화 시작/중지">
        <span class="ring"></span>
        <span class="inner"></span>
      </button>
    </div>
  </div>
</main>

<section id="playbackArea" class="playback hidden" aria-hidden="true">
  <div class="playback-header">
    <div class="playback-title">영상 재생</div>
    <div class="playback-actions">
      <button id="saveBtn" class="btn primary">저장</button>
      <button id="closePlayback" class="btn ghost">닫기</button>
    </div>
  </div>
  <div class="playback-body">
    <!-- controls 속성 제거: 재생 속도 제어를 커스텀 버튼으로 강제함 -->
    <video id="playback" playsinline></video> 
    <div id="speedOverlay" class="speed-overlay">30fps (1x)</div>
  </div>
  <div class="playback-controls">
    <button id="speed30" class="btn speed active" data-speed="30">30fps (1x)</button>
    <button id="speed240" class="btn speed" data-speed="240">240fps (1/8x)</button>
  </div>
  <p class="note">저장 후 공유 시트에서 '비디오 저장'을 선택해 사진 앱에 저장하세요.</p>
</section>

<input id="fileInput" type="file" accept="video/*" style="display:none">

<div id="message" class="message hidden" role="status"></div>
</div><script>/* Golf Swing Recorder - Professional VersionFixed: Recording button, 240fps detection, playback speeds (30fps/240fps), beep sound, timer*/document.addEventListener('DOMContentLoaded', () => {const preview = document.getElementById('preview');const recordBtn = document.getElementById('recordBtn');const fpsSelect = document.getElementById('fpsSelect');const fileInput = document.getElementById('fileInput');const galleryBtn = document.getElementById('galleryBtn');const playbackArea = document.getElementById('playbackArea');const playback = document.getElementById('playback');const saveBtn = document.getElementById('saveBtn');const closePlayback = document.getElementById('closePlayback');const speed30 = document.getElementById('speed30');const speed240 = document.getElementById('speed240');const speedOverlay = document.getElementById('speedOverlay');const message = document.getElementById('message');const topTimer = document.getElementById('topTimer'); // Onform-like timer elementconst topTimerWrap = document.getElementById('topTimerWrap'); // Timer containerlet mediaStream = null;let mediaRecorder = null;let recordedChunks = [];let isRecording = false;let timerInterval = null;let timerT0 = 0;let audioContext = null;const supportsGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);const supportsMediaRecorder = typeof MediaRecorder !== 'undefined';let is240fpsSupported = false; // Global flag for 240fps supportfunction showMessage(txt, ms=2000) {message.textContent = txt;message.classList.remove('hidden');if (message._timeout) clearTimeout(message._timeout);message._timeout = setTimeout(() => message.classList.add('hidden'), ms);}function chooseMimeType() {// Priority: video/mp4 for better compatibility and playback on iOS/macOSconst candidates = ['video/mp4;codecs=avc1','video/mp4','video/webm;codecs=vp9','video/webm',];for (const type of candidates) {if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(type)) {return type;}}return '';}// 요청하신 '녹화 버튼을 눌렀을 때에 실행이 되면 소리가 나게' 하는 기능function playBeep() {try {if (!audioContext) {audioContext = new (window.AudioContext || window.webkitAudioContext)();}  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.frequency.value = 880; 
  oscillator.type = &#39;sine&#39;;
  
  gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
  
  oscillator.start(audioContext.currentTime);
  oscillator.stop(audioContext.currentTime + 0.1);
  
  console.log(&#39;Beep played successfully&#39;);
} catch (e) {
  console.warn(&#39;Beep failed:&#39;, e);
}
}async function startPreview() {if (!supportsGetUserMedia) {showMessage('카메라를 지원하지 않는 브라우저입니다.', 5000);return false;}const selectedFps = Number(fpsSelect.value);

// Stop existing tracks first
if (mediaStream) {
  mediaStream.getTracks().forEach(t =&gt; t.stop());
}

// Request constraints based on selected FPS
const constraints = {
  audio: true,
  video: {
    facingMode: { ideal: &quot;environment&quot; },
    width: { ideal: 1920 },
    height: { ideal: 1080 },
    // Use ideal/max for 240fps, or exact for 30fps
    frameRate: selectedFps === 240 &amp;&amp; is240fpsSupported
      ? { ideal: 240, max: 240 }
      : { exact: 30 }
  }
};

try {
  mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
  preview.srcObject = mediaStream;
  await preview.play();

  const videoTrack = mediaStream.getVideoTracks()[0];
  const settings = videoTrack.getSettings();
  const actualFps = settings.frameRate || 30; // Fallback to 30

  // Update FPS select value based on actual settings, in case 240fps was requested but 
  // only a lower high-speed FPS (like 120) was granted.
  // We prioritize the requested 240 setting for the UI, but acknowledge actual capture rate.
  const currentSelectedFps = actualFps &gt; 60 ? 240 : 30;
  fpsSelect.value = currentSelectedFps.toString();
  
  console.log(&#39;Camera started - Requested:&#39;, selectedFps, &#39;Actual:&#39;, actualFps);
  showMessage(`카메라 준비 완료 (${Math.round(actualFps)}fps)`, 1500);
  
  return true;
} catch (err) {
  console.error(&#39;getUserMedia error:&#39;, err);
  // If 240fps fails, try 30fps as a fallback
  if (selectedFps === 240) {
    showMessage(&#39;240fps 접근 실패. 30fps로 시도합니다.&#39;, 3000);
    fpsSelect.value = &#39;30&#39;;
    return await startPreview(); // Recursive call with 30fps
  } else {
    showMessage(&#39;카메라 접근 실패: &#39; + (err.message || &#39;알 수 없는 오류&#39;), 4000);
    return false;
  }
}
}// 요청하신 '녹화진행 사항을 시계로 볼 수 있는 기능(Onform app처럼)'function startTimer() {timerT0 = performance.now();topTimer.textContent = '00:00.00';topTimerWrap.classList.add('active'); // Show timertimerInterval = setInterval(() =&gt; {
  const elapsed = performance.now() - timerT0;
  const minutes = Math.floor(elapsed / 60000);
  const seconds = Math.floor((elapsed % 60000) / 1000);
  const centiseconds = Math.floor((elapsed % 1000) / 10); // 1/100초

  const mm = String(minutes).padStart(2, &#39;0&#39;);
  const ss = String(seconds).padStart(2, &#39;0&#39;);
  const cc = String(centiseconds).padStart(2, &#39;0&#39;);
  
  topTimer.textContent = `${mm}:${ss}.${cc}`;
}, 50); // Update every 50ms for 1/100s precision
}function stopTimer() {if (timerInterval) {clearInterval(timerInterval);timerInterval = null;}topTimerWrap.classList.remove('active'); // Hide timer}// 녹화 시작/중지 로직 수정 및 통합async function startRecording() {if (!supportsMediaRecorder) {showMessage('녹화를 지원하지 않는 브라우저입니다.', 4000);return;}if (!mediaStream || !mediaStream.active) {
  const started = await startPreview();
  if (!started) return;
}

recordedChunks = [];
const mimeType = chooseMimeType();

try {
  const options = mimeType ? { mimeType } : {};
  mediaRecorder = new MediaRecorder(mediaStream, options);
  
  mediaRecorder.ondataavailable = (event) =&gt; {
    if (event.data &amp;&amp; event.data.size &gt; 0) {
      recordedChunks.push(event.data);
    }
  };

  mediaRecorder.onstop = handleRecordingStop;
  
  mediaRecorder.onerror = (event) =&gt; {
    console.error(&#39;MediaRecorder error:&#39;, event);
    showMessage(&#39;녹화 중 오류가 발생했습니다&#39;, 3000);
    // Call stopRecording to clean up state
    stopRecording();
  };
  
  // 녹화 시작 시 소리 재생
  playBeep();
  
  // 약간의 딜레이 후 녹화 시작
  await new Promise(resolve =&gt; setTimeout(resolve, 100));

  mediaRecorder.start(1000); // Collect data every 1000ms (1 second)
  isRecording = true;
  
  recordBtn.classList.add(&#39;recording&#39;);
  recordBtn.setAttribute(&#39;aria-pressed&#39;, &#39;true&#39;);
  
  startTimer(); // Start the Onform-like timer
  showMessage(&#39;🔴 녹화 시작&#39;, 1000);
  
} catch (err) {
  console.error(&#39;Failed to start recording:&#39;, err);
  showMessage(&#39;녹화를 시작할 수 없습니다: &#39; + err.message, 3000);
  isRecording = false;
  recordBtn.classList.remove(&#39;recording&#39;);
}
}function stopRecording() {if (!isRecording || !mediaRecorder) {return;}try {
  if (mediaRecorder.state !== &#39;inactive&#39;) {
    mediaRecorder.stop();
  }
  
  isRecording = false;
  recordBtn.classList.remove(&#39;recording&#39;);
  recordBtn.setAttribute(&#39;aria-pressed&#39;, &#39;false&#39;);
  stopTimer(); // Stop the Onform-like timer
  
  showMessage(&#39;녹화 중지&#39;, 1000);
} catch (err) {
  console.error(&#39;Error stopping recording:&#39;, err);
}
}function handleRecordingStop() {if (recordedChunks.length === 0) {showMessage('녹화된 데이터가 없습니다', 2000);return;}try {
  // Use the MIME type determined by MediaRecorder
  const mimeType = mediaRecorder.mimeType || &#39;video/webm&#39;; 
  const blob = new Blob(recordedChunks, { type: mimeType });
  
  if (blob.size &lt; 1000) {
    showMessage(&#39;녹화된 데이터가 너무 작습니다. 다시 시도해주세요.&#39;, 3000);
    return;
  }
  
  const url = URL.createObjectURL(blob);
  openPlayback(url, blob);

} catch (err) {
  console.error(&#39;Error handling recording stop:&#39;, err);
  showMessage(&#39;녹화 파일 처리 중 오류가 발생했습니다&#39;, 3000);
}
}function openPlayback(url, file) {playbackArea.classList.remove('hidden');playbackArea.setAttribute('aria-hidden', 'false');playback.src = url;
playback.playbackRate = 1.0; 

saveBtn.onclick = () =&gt; saveVideo(file);

// 갤러리/녹화 영상 모두 30fps 기본 재생 속도로 시작
setPlaybackSpeed(30);

// iOS에서 플레이백 비디오가 잘 보이도록 강제로 play 시도
playback.onloadedmetadata = () =&gt; {
    playback.play().catch(e =&gt; console.warn(&#39;Autoplay failed:&#39;, e));
};

// 항상 재생 속도 버튼이 활성화되도록 제어
speed30.disabled = false;
speed240.disabled = false;
}// 요청하신 '사진첩에서 불러온 영상이 30fps과 240fps으로 재생이 잘되지 않는다. 이 두가지 속도로만 재생이 되게 해줘' 기능function setPlaybackSpeed(fps) {if (!playback.src) return;// 30fps = 정상 속도 (1.0x)
// 240fps = 슬로우 모션 (1/8 속도 = 0.125x)
const rate = fps === 30 ? 1.0 : 0.125;
playback.playbackRate = rate;

speedOverlay.textContent = fps === 30 ? &#39;30fps (1x)&#39; : &#39;240fps (1/8x)&#39;;

// 버튼 상태 업데이트
speed30.classList.toggle(&#39;active&#39;, fps === 30);
speed240.classList.toggle(&#39;active&#39;, fps === 240);

// 재생 버튼이 활성화된 상태에서 속도 변경 시 바로 재생되도록 설정
if (playback.paused) {
  playback.play().catch(e =&gt; console.warn(&#39;Play failed after speed change:&#39;, e));
}

console.log(&#39;Playback speed set to:&#39;, rate, &#39;for&#39;, fps, &#39;fps&#39;);
}async function saveVideo(file) {if (!file) {showMessage('저장할 파일이 없습니다', 2000);return;}// 파일 이름 정의 (확장자는 blob 타입에 따라 결정)
const mimeType = file.type || &#39;video/webm&#39;;
const extension = mimeType.includes(&#39;mp4&#39;) ? &#39;mp4&#39; : (mimeType.includes(&#39;webm&#39;) ? &#39;webm&#39; : &#39;video&#39;);
const fileName = `swing_${Date.now()}.${extension}`;

// 파일 Blob을 얻습니다. (File 객체라면 그대로 사용, Blob URL이라면 fetch로 Blob으로 변환)
let blobToSave = file instanceof Blob ? file : await (await fetch(file.src)).blob();

try {
  // 1. Web Share API 시도 (iOS에서 가장 좋은 저장 경험 제공)
  if (navigator.share &amp;&amp; navigator.canShare) {
    const fileToShare = new File([blobToSave], fileName, { type: blobToSave.type });
    
    if (navigator.canShare({ files: [fileToShare] })) {
      await navigator.share({
        files: [fileToShare],
        title: &#39;골프 스윙 영상&#39;
      });
      showMessage(&#39;공유 완료. 공유 시트에서 &quot;비디오 저장&quot;을 선택하세요.&#39;, 3500);
      return;
    }
  }
} catch (err) {
  console.log(&#39;Share API failed or cancelled (정상적인 취소):&#39;, err);
}

// 2. Fallback: 다운로드 링크 생성
const url = URL.createObjectURL(blobToSave);
const a = document.createElement(&#39;a&#39;);
a.href = url;
a.download = fileName;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);

showMessage(&#39;다운로드 시작. 파일을 길게 눌러 사진 앱에 저장하세요.&#39;, 4000);
}// --- Event Listeners ---recordBtn.addEventListener('click', async (e) => {e.preventDefault();// 녹화 중일 때: 중지, 녹화 중이 아닐 때: 시작if (isRecording) {stopRecording();} else {await startRecording();}});closePlayback.addEventListener('click', () => {playback.pause();playback.src = '';playback.removeAttribute('src'); // Clean up srcplaybackArea.classList.add('hidden');playbackArea.setAttribute('aria-hidden', 'true');// 재생 속도 버튼 초기화speed30.classList.add('active');speed240.classList.remove('active');});speed30.addEventListener('click', () => setPlaybackSpeed(30));speed240.addEventListener('click', () => setPlaybackSpeed(240));galleryBtn.addEventListener('click', () => {fileInput.click();});fileInput.addEventListener('change', (e) => {const file = e.target.files[0];if (!file || !file.type.startsWith('video/')) {showMessage('유효한 비디오 파일이 아닙니다.', 1200);fileInput.value = ''; // Reset file inputreturn;}const url = URL.createObjectURL(file);
openPlayback(url, file); // Blob/File 객체를 그대로 전달

showMessage(&#39;갤러리에서 불러옴&#39;, 1200);

// Reset file input
fileInput.value = &#39;&#39;;
});// FPS 선택이 변경될 때: 미리보기 다시 시작fpsSelect.addEventListener('change', async () => {if (isRecording) {showMessage('녹화 중에는 FPS를 변경할 수 없습니다', 2000);return;}recordBtn.disabled = true; // 잠시 녹화 버튼 비활성화
await startPreview();
recordBtn.disabled = false; // 다시 활성화
});// 요청하신 '240pfs가 비활성(작동을 하지 않음) 이다.' 에 대한 수정async function check240fpsSupport() {const option240 = fpsSelect.querySelector('option[value="240"]');if (!option240) return false;// 기본적으로 240fps 옵션을 비활성화하고 지원 여부에 따라 활성화합니다.
option240.disabled = true;
option240.textContent = &#39;240fps (확인 중)&#39;;

try {
  // 240fps를 시도하여 최대 지원 프레임률 확인
  const testStream = await navigator.mediaDevices.getUserMedia({
    video: { 
      frameRate: { ideal: 240, max: 240 } 
    }
  });
  
  const videoTrack = testStream.getVideoTracks()[0];
  const settings = videoTrack.getSettings();
  
  testStream.getTracks().forEach(t =&gt; t.stop());
  
  const actualFps = settings.frameRate || 0;
  
  // 실제 지원 FPS가 고속 프레임 (예: 120fps 이상)인지 확인
  if (actualFps &gt;= 120) {
    is240fpsSupported = true;
    option240.disabled = false;
    option240.textContent = &#39;240fps (슬로우 모션)&#39;;
    console.log(`240fps (실제 지원: ${actualFps}fps) 지원 확인`);
    return true;
  } else {
    option240.textContent = `240fps (미지원: Max ${Math.round(actualFps)}fps)`;
    console.log(`240fps 미지원. 최대 FPS: ${Math.round(actualFps)}`);
    return false;
  }
} catch (err) {
  console.warn(&#39;240fps check failed, falling back to 30fps:&#39;, err.message);
  option240.textContent = &#39;240fps (미지원)&#39;;
  return false;
}
}// Initialize(async function init() {console.log('Initializing Golf Swing Recorder...');if (!supportsGetUserMedia || !supportsMediaRecorder) {
  showMessage(&#39;카메라 또는 녹화 기능을 지원하지 않습니다.&#39;, 6000);
  recordBtn.disabled = true;
  return;
}

// 240fps 지원 여부를 먼저 확인
await check240fpsSupport();

// 기본 설정(30fps)으로 미리보기 시작
await startPreview();

console.log(&#39;Initialization complete&#39;);
})();});</script></body></html>